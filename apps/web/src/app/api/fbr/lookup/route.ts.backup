import { NextRequest, NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { auth } from '@/auth'

const prisma = new PrismaClient()

// Mock FBR data for development - replace with real PRAL API calls later
const MOCK_FBR_DATA = {
  provinces: [
    { code: 'PB', name: 'Punjab', description: 'Punjab Province' },
    { code: 'SD', name: 'Sindh', description: 'Sindh Province' },
    { code: 'KP', name: 'Khyber Pakhtunkhwa', description: 'Khyber Pakhtunkhwa Province' },
    { code: 'BL', name: 'Balochistan', description: 'Balochistan Province' },
    { code: 'GB', name: 'Gilgit-Baltistan', description: 'Gilgit-Baltistan' },
    { code: 'AK', name: 'Azad Kashmir', description: 'Azad Kashmir' },
    { code: 'ICT', name: 'Islamabad', description: 'Islamabad Capital Territory' }
  ],
  hsCodes: [
    // Food & Agriculture
    { code: '1006.3090', description: 'Rice (Other varieties)' },
    { code: '2501.0010', description: 'Salt (Table salt)' },
    { code: '1701.1410', description: 'Sugar (Cane sugar, raw)' },
    { code: '1005.9000', description: 'Maize (Corn)' },
    { code: '1001.9990', description: 'Wheat (Other)' },
    { code: '0713.3390', description: 'Beans (Other dried beans)' },
    { code: '1008.2990', description: 'Millet (Other)' },
    { code: '0902.3000', description: 'Tea (Black tea in packages > 3kg)' },
    
    // Petroleum & Oil Products (HS Code 27)
    { code: '2709.0000', description: 'Petroleum oils and oils obtained from bituminous minerals, crude' },
    { code: '2710.1100', description: 'Light oils and preparations - Motor spirit (Petrol/Gasoline)' },
    { code: '2710.1200', description: 'Light oils and preparations - Motor spirit for aviation' },
    { code: '2710.1910', description: 'Light oils and preparations - White spirit' },
    { code: '2710.1920', description: 'Light oils and preparations - Aviation turbine fuel' },
    { code: '2710.1930', description: 'Light oils and preparations - Jet fuel' },
    { code: '2710.1990', description: 'Light oils and preparations - Other light oils' },
    { code: '2710.1941', description: 'Kerosene' },
    { code: '2710.1949', description: 'Other medium oils and preparations' },
    { code: '2710.1951', description: 'Diesel oil' },
    { code: '2710.1952', description: 'Fuel oils' },
    { code: '2710.1953', description: 'Lubricating oils and greases' },
    { code: '2710.1990', description: 'Other petroleum oils (Heavy oils)' },
    { code: '2711.1100', description: 'Liquefied natural gas (LNG)' },
    { code: '2711.1200', description: 'Liquefied propane' },
    { code: '2711.1300', description: 'Liquefied butanes' },
    { code: '2711.1400', description: 'Liquefied ethylene, propylene, butylene and butadiene' },
    
    // Electronics & Technology
    { code: '8523.4990', description: 'Software - Digital media (Other)' },
    { code: '8471.3000', description: 'Computers - Portable automatic data processing machines' },
    { code: '8517.6200', description: 'Networking equipment - Routers and modems' },
    { code: '8528.7200', description: 'Monitors - LED displays' },
    { code: '8443.3200', description: 'Printers - Multi-function machines' },
    { code: '8504.4090', description: 'Power supplies - Static converters (Other)' },
    
    // Other Products
    { code: '3926.9090', description: 'Plastic articles - Other articles' },
    { code: '4820.1000', description: 'Stationery - Registers, account books' },
    { code: '9403.7000', description: 'Furniture - Plastic furniture' },
    { code: '6307.9090', description: 'Textile articles - Other made up articles' }
  ],
  transactionTypes: [
    { transTypeId: 1, transTypeDesc: 'Supply of Goods' },
    { transTypeId: 2, transTypeDesc: 'Supply of Services' },
    { transTypeId: 3, transTypeDesc: 'Export of Goods' },
    { transTypeId: 4, transTypeDesc: 'Export of Services' },
    { transTypeId: 5, transTypeDesc: 'Import of Goods' },
    { transTypeId: 6, transTypeDesc: 'Import of Services' },
    { transTypeId: 7, transTypeDesc: 'Zero Rated Supply' },
    { transTypeId: 8, transTypeDesc: 'Exempt Supply' },
    { transTypeId: 9, transTypeDesc: 'Advance Payment' },
    { transTypeId: 10, transTypeDesc: 'Return/Credit Note' }
  ],
  documentTypes: [
    { code: 'SI', description: 'Sale Invoice' },
    { code: 'CN', description: 'Credit Note' },
    { code: 'DN', description: 'Debit Note' }
  ],
  scenarios: [
    { code: 'SN001', description: 'Registered to Registered' },
    { code: 'SN002', description: 'Registered to Unregistered' },
    { code: 'SN003', description: 'Export Sales' },
    { code: 'SN004', description: 'Zero Rated Sales' }
  ],
  paymentModes: [
    { code: '1', description: 'Cash' },
    { code: '2', description: 'Credit Card' },
    { code: '3', description: 'Debit Card' },
    { code: '4', description: 'Cheque' },
    { code: '5', description: 'Bank Transfer' }
  ],
  uom: {
    '1006.3090': [
      { code: 'KG', description: 'Kilogram' },
      { code: 'TON', description: 'Metric Ton' },
      { code: 'BAG', description: 'Bag' }
    ],
    '2501.0010': [
      { code: 'KG', description: 'Kilogram' },
      { code: 'TON', description: 'Metric Ton' }
    ],
    'default': [
      { code: 'PCS', description: 'Pieces' },
      { code: 'KG', description: 'Kilogram' },
      { code: 'LTR', description: 'Liter' },
      { code: 'MTR', description: 'Meter' }
    ]
  } as Record<string, Array<{ code: string; description: string }>>,
  saleTypes: {
    '1006.3090': {
      'SN001': [
        { code: 'GSR', description: 'Goods at standard rate' },
        { code: 'GZR', description: 'Goods at zero rate' }
      ],
      'SN002': [
        { code: 'GSR', description: 'Goods at standard rate' },
        { code: 'GER', description: 'Goods exempt from tax' }
      ]
    },
    'default': {
      'default': [
        { code: 'GSR', description: 'Goods at standard rate' },
        { code: 'GZR', description: 'Goods at zero rate' },
        { code: 'GER', description: 'Goods exempt from tax' }
      ]
    }
  } as Record<string, Record<string, Array<{ code: string; description: string }>>>
}

// Cache management functions
async function updateCache(lookupType: string, data: any[]) {
  try {
    // Clear existing cache data
    switch (lookupType) {
      case 'provinces':
        await prisma.fBRProvince.deleteMany()
        await prisma.fBRProvince.createMany({
          data: data.map(item => ({
            code: item.code,
            name: item.name,
            description: item.description
          }))
        })
        break
      
      case 'hscodes':
        await prisma.fBRHSCode.deleteMany()
        await prisma.fBRHSCode.createMany({
          data: data.map(item => ({
            code: item.code,
            description: item.description
          }))
        })
        break
      
      case 'documentTypes':
        await prisma.fBRDocumentType.deleteMany()
        await prisma.fBRDocumentType.createMany({
          data: data.map(item => ({
            code: item.code,
            description: item.description
          }))
        })
        break
      
      case 'scenarios':
        await prisma.fBRScenario.deleteMany()
        await prisma.fBRScenario.createMany({
          data: data.map(item => ({
            code: item.code,
            description: item.description
          }))
        })
        break
      
      case 'paymentModes':
        await prisma.fBRPaymentMode.deleteMany()
        await prisma.fBRPaymentMode.createMany({
          data: data.map(item => ({
            code: item.code,
            description: item.description
          }))
        })
        break
    }

    // Update cache metadata
    await prisma.fBRCacheMetadata.upsert({
      where: { lookupType },
      update: {
        lastSyncAt: new Date(),
        recordCount: data.length,
        syncStatus: 'success',
        errorMessage: null
      },
      create: {
        lookupType,
        lastSyncAt: new Date(),
        recordCount: data.length,
        syncStatus: 'success'
      }
    })

    console.log(`‚úÖ Updated ${lookupType} cache with ${data.length} records`)
  } catch (error) {
    console.error(`‚ùå Failed to update ${lookupType} cache:`, error)
    
    // Update cache metadata with error
    await prisma.fBRCacheMetadata.upsert({
      where: { lookupType },
      update: {
        syncStatus: 'failed',
        errorMessage: error instanceof Error ? error.message : 'Unknown error'
      },
      create: {
        lookupType,
        lastSyncAt: new Date(),
        recordCount: 0,
        syncStatus: 'failed',
        errorMessage: error instanceof Error ? error.message : 'Unknown error'
      }
    })
  }
}

async function getCachedData(lookupType: string, filter?: any) {
  try {
    switch (lookupType) {
      case 'provinces':
        return await prisma.fBRProvince.findMany({
          where: { isActive: true },
          orderBy: { name: 'asc' }
        })
      
      case 'hscodes':
        return await prisma.fBRHSCode.findMany({
          where: { isActive: true },
          orderBy: { code: 'asc' }
        })
      
      case 'documentTypes':
        return await prisma.fBRDocumentType.findMany({
          where: { isActive: true },
          orderBy: { description: 'asc' }
        })
      
      case 'scenarios':
        return await prisma.fBRScenario.findMany({
          where: { isActive: true },
          orderBy: { code: 'asc' }
        })
      
      case 'paymentModes':
        return await prisma.fBRPaymentMode.findMany({
          where: { isActive: true },
          orderBy: { code: 'asc' }
        })
      
      case 'uom':
        if (filter?.hsCode) {
          return await prisma.fBRUnitOfMeasurement.findMany({
            where: { 
              isActive: true,
              OR: [
                { hsCode: filter.hsCode },
                { hsCode: null } // Include generic UOMs
              ]
            },
            orderBy: { description: 'asc' }
          })
        }
        return await prisma.fBRUnitOfMeasurement.findMany({
          where: { isActive: true },
          orderBy: { description: 'asc' }
        })
      
      default:
        return []
    }
  } catch (error) {
    console.error(`‚ùå Failed to get cached data for ${lookupType}:`, error)
    return []
  }
}

async function initializeCache() {
  console.log('üîÑ Initializing FBR cache with mock data...')
  
  // Initialize with mock data
  await updateCache('provinces', MOCK_FBR_DATA.provinces)
  await updateCache('hscodes', MOCK_FBR_DATA.hsCodes)
  await updateCache('documentTypes', MOCK_FBR_DATA.documentTypes)
  await updateCache('scenarios', MOCK_FBR_DATA.scenarios)
  await updateCache('paymentModes', MOCK_FBR_DATA.paymentModes)
  
  // Initialize UOM data
  const uomData = []
  for (const [hsCode, uoms] of Object.entries(MOCK_FBR_DATA.uom)) {
    if (hsCode === 'default') {
      // Add generic UOMs without HS code
      for (const uom of uoms) {
        uomData.push({ code: uom.code, description: uom.description, hsCode: null })
      }
    } else {
      // Add HS code specific UOMs
      for (const uom of uoms) {
        uomData.push({ code: uom.code, description: uom.description, hsCode })
      }
    }
  }
  
  await prisma.fBRUnitOfMeasurement.deleteMany()
  await prisma.fBRUnitOfMeasurement.createMany({ data: uomData })
  
  console.log('‚úÖ FBR cache initialization complete')
}

export async function GET(request: NextRequest) {
  try {
    const session = await auth()
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const type = searchParams.get('type') // Changed from lookupType to type for consistency
    const hsCode = searchParams.get('hsCode')
    const scenarioId = searchParams.get('scenarioId')
    const query = searchParams.get('query') // For search queries
    const force = searchParams.get('force') === 'true'

    if (!type) {
      return NextResponse.json({ error: 'type parameter is required' }, { status: 400 })
    }

    console.log(`üìã FBR Lookup Request: ${type}`, { hsCode, scenarioId, query, force })

    // Handle HS Code Search
    if (type === 'hsCodeSearch' && query) {
      console.log(`üîç HS Code Search: "${query}"`)
      
      // Filter HS codes by search query
      const searchResults = MOCK_FBR_DATA.hsCodes.filter(hscode => 
        hscode.code.toLowerCase().includes(query.toLowerCase()) ||
        hscode.description.toLowerCase().includes(query.toLowerCase())
      ).slice(0, 10) // Limit to 10 results

      const data = searchResults.map(h => ({
        hS_CODE: h.code,
        description: h.description
      }))

      console.log(`‚úÖ HS Code Search Results: ${data.length} matches`)

      return NextResponse.json({
        success: true,
        data,
        metadata: {
          query,
          recordCount: data.length
        }
      })
    }

    // Handle Transaction Types
    if (type === 'transactionTypes') {
      console.log(`üìã Fetching Transaction Types`)
      
      const data = MOCK_FBR_DATA.transactionTypes

      return NextResponse.json({
        success: true,
        data,
        metadata: {
          recordCount: data.length
        }
      })
    }

    // Check if we need to initialize cache
    const cacheMetadata = await prisma.fBRCacheMetadata.findUnique({
      where: { lookupType: type }
    })

    if (!cacheMetadata || force) {
      await initializeCache()
    }

    // Get cached data
    let data: any[] = await getCachedData(type, { hsCode, scenarioId })

    // If no cached data, use mock data directly
    if (data.length === 0) {
      switch (type) {
        case 'provinces':
          data = MOCK_FBR_DATA.provinces.map(p => ({
            stateProvinceCode: MOCK_FBR_DATA.provinces.indexOf(p) + 1,
            stateProvinceDesc: p.name
          }))
          break
        
        case 'hsCodes':
          data = MOCK_FBR_DATA.hsCodes.map(h => ({
            hS_CODE: h.code,
            description: h.description
          }))
          break
        
        case 'uom':
          if (hsCode && MOCK_FBR_DATA.uom[hsCode]) {
            data = MOCK_FBR_DATA.uom[hsCode].map((u, i) => ({
              uoM_ID: i + 1,
              description: u.description
            }))
          } else {
            data = MOCK_FBR_DATA.uom.default.map((u, i) => ({
              uoM_ID: i + 1,
              description: u.description
            }))
          }
          break
        
        case 'saleTypes':
          if (hsCode && scenarioId) {
            const hsCodeData = MOCK_FBR_DATA.saleTypes[hsCode] || MOCK_FBR_DATA.saleTypes.default
            data = hsCodeData[scenarioId] || hsCodeData.default || []
          } else {
            data = MOCK_FBR_DATA.saleTypes.default.default
          }
          break
        
        default:
          const mockData = MOCK_FBR_DATA[type as keyof typeof MOCK_FBR_DATA]
          data = Array.isArray(mockData) ? mockData : []
      }
    }

    console.log(`‚úÖ FBR Lookup Response: ${type} - ${data.length} records`)

    return NextResponse.json({
      success: true,
      data,
      metadata: {
        lookupType: type,
        recordCount: data.length,
        cached: cacheMetadata !== null,
        lastSync: cacheMetadata?.lastSyncAt
      }
    })

  } catch (error) {
    console.error('‚ùå FBR Lookup API Error:', error)
    return NextResponse.json({
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await auth()
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { type, hsCode, scenarioId, action } = body

    console.log(`üìã FBR Lookup POST Request:`, { type, hsCode, scenarioId, action })

    // Handle cache refresh action
    if (action === 'refresh-cache') {
      console.log(`üîÑ Refreshing ${type || 'all'} cache...`)
      
      if (type) {
        // Refresh specific lookup type
        const mockData = MOCK_FBR_DATA[type as keyof typeof MOCK_FBR_DATA]
        if (mockData) {
          await updateCache(type, Array.isArray(mockData) ? mockData : [])
        }
      } else {
        // Refresh all cache
        await initializeCache()
      }
      
      return NextResponse.json({
        success: true,
        message: `Cache refreshed for ${type || 'all lookup types'}`
      })
    }

    // Handle data chaining requests (e.g., hsUom)
    if (type === 'hsUom' && hsCode) {
      console.log(`üîó Data Chaining: Fetching UOMs for HS Code ${hsCode}`)
      
      // Get UOMs specific to this HS code
      let data = await prisma.fBRUnitOfMeasurement.findMany({
        where: { 
          isActive: true,
          hsCode: hsCode
        },
        orderBy: { description: 'asc' }
      })

      // If no specific UOMs found, fall back to mock data or generic UOMs
      if (data.length === 0) {
        if (MOCK_FBR_DATA.uom[hsCode]) {
          data = MOCK_FBR_DATA.uom[hsCode].map((u, i) => ({
            id: `uom-${hsCode}-${i}`,
            uoM_ID: i + 1,
            description: u.description,
            code: u.code,
            hsCode: hsCode,
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
          })) as any
        } else {
          // Use generic UOMs
          data = MOCK_FBR_DATA.uom.default.map((u, i) => ({
            id: `uom-default-${i}`,
            uoM_ID: i + 1,
            description: u.description,
            code: u.code,
            hsCode: null,
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
          })) as any
        }
      }

      console.log(`‚úÖ Found ${data.length} UOMs for HS Code ${hsCode}`)

      return NextResponse.json({
        success: true,
        data,
        metadata: {
          hsCode,
          recordCount: data.length,
          message: data.length > 0 ? `Valid UOMs for HS Code ${hsCode}` : `No specific UOMs for ${hsCode}, using generic UOMs`
        }
      })
    }

    // Handle sale type lookups (HS Code + Scenario chaining)
    if (type === 'saleTypes' && hsCode && scenarioId) {
      console.log(`üîó Data Chaining: Fetching Sale Types for HS Code ${hsCode} and Scenario ${scenarioId}`)
      
      const hsCodeData = MOCK_FBR_DATA.saleTypes[hsCode] || MOCK_FBR_DATA.saleTypes.default
      const data = hsCodeData[scenarioId] || hsCodeData.default || []

      return NextResponse.json({
        success: true,
        data,
        metadata: {
          hsCode,
          scenarioId,
          recordCount: data.length
        }
      })
    }

    return NextResponse.json({ error: 'Invalid request parameters' }, { status: 400 })

  } catch (error) {
    console.error('‚ùå FBR Lookup POST Error:', error)
    return NextResponse.json({
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}